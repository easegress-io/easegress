package tcpserver

import (
	"github.com/megaease/easegress/pkg/protocol"
	"sync/atomic"

	"github.com/megaease/easegress/pkg/supervisor"
	"github.com/megaease/easegress/pkg/util/limitlistener"
	"github.com/megaease/easegress/pkg/util/tcpstat"
)

const (
	// Category is the category of HTTPServer.
	Category = supervisor.CategoryTrafficGate

	// Kind is the kind of HTTPServer.
	Kind = "TCPServer"
)

func init() {
	supervisor.Register(&TCPServer{})
}

type (
	stateType string

	eventCheckFailed struct{}
	eventServeFailed struct {
		startNum uint64
		err      error
	}
	eventReload struct {
		nextSuperSpec *supervisor.Spec
	}
	eventClose struct{ done chan struct{} }

	TCPServer struct {
		superSpec *supervisor.Spec
		spec      *Spec
		startNum  uint64
		eventChan chan interface{}

		// status
		state atomic.Value // stateType
		err   atomic.Value // error

		tcpstat       *tcpstat.TcpStat
		limitListener *limitlistener.LimitListener
	}

	// Status contains all status generated by runtime, for displaying to users.
	Status struct {
		Health string `yaml:"health"`

		State stateType `yaml:"state"`
		Error string    `yaml:"error,omitempty"`

		*tcpstat.Status
	}
)

func (T *TCPServer) Category() supervisor.ObjectCategory {
	return Category
}

func (T *TCPServer) Kind() string {
	return Kind
}

func (T *TCPServer) DefaultSpec() interface{} {
	return &Spec{
		KeepAlive:      true,
		MaxConnections: 10240,
	}
}

func (T *TCPServer) Status() *supervisor.Status {
	panic("implement me")
}

func (T *TCPServer) Close() {
	panic("implement me")
}

// Init initializes HTTPServer.
func (T *TCPServer) Init(superSpec *supervisor.Spec, muxMapper protocol.MuxMapper) {
	panic("implement me")
}

// Inherit inherits previous generation of HTTPServer.
func (T *TCPServer) Inherit(superSpec *supervisor.Spec, previousGeneration supervisor.Object, muxMapper protocol.MuxMapper) {
	panic("implement me")
}
