/*
 * Copyright (c) 2017, MegaEase
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package spec

import (
	"fmt"
)

type (
	// functionFSM is a finite state machine for managing faas function.
	FSM struct {
		currentState State
	}

	// Event is the event type generated by CLI or FaaSProvider.
	Event string

	// State is the FaaSFunction's state.
	State string

	// transition builds a role for state changing
	transition struct {
		From  State
		Event Event
		To    State
	}
)

const (
	// State value of FaaSFunction
	FailedState   State = "failed"
	PendingState  State = "pending"
	ActiveState   State = "active"
	InactiveState State = "inactive"

	// only for keep fsm working
	RemovedState State = "removed"

	// Function event
	CreateEvent Event = "create"
	StartEvent  Event = "start"
	StopEvent   Event = "stop"
	UpdateEvent Event = "update"
	DeleteEvent Event = "delete"

	// Event fired by FaaSProvider
	ProvisionOKEvent      Event = "provisionsOK"
	ProvisionPendingEvent Event = "provisionPending"
	ProvisionFailedEvent  Event = "provisionFailed"
)

var (
	validState []State = []State{PendingState, ActiveState, InactiveState, FailedState, RemovedState}
	validEvent []Event = []Event{UpdateEvent, DeleteEvent, StopEvent, StartEvent,
		ProvisionFailedEvent, ProvisionPendingEvent, ProvisionOKEvent}

	transitions []transition = []transition{
		{PendingState, UpdateEvent, PendingState},
		{PendingState, DeleteEvent, RemovedState},
		{PendingState, ProvisionFailedEvent, FailedState},
		{PendingState, ProvisionOKEvent, ActiveState},
		{PendingState, ProvisionPendingEvent, PendingState},

		{ActiveState, StopEvent, InactiveState},
		{ActiveState, ProvisionFailedEvent, FailedState},
		{ActiveState, ProvisionOKEvent, ActiveState},
		{ActiveState, ProvisionPendingEvent, PendingState},

		{InactiveState, UpdateEvent, PendingState},
		{InactiveState, DeleteEvent, RemovedState},
		{InactiveState, StartEvent, ActiveState},
		{InactiveState, ProvisionFailedEvent, FailedState},
		{InactiveState, ProvisionOKEvent, InactiveState},
		{InactiveState, ProvisionPendingEvent, PendingState},

		{FailedState, DeleteEvent, RemovedState},
		{FailedState, UpdateEvent, PendingState},
		{FailedState, ProvisionFailedEvent, FailedState},
		{FailedState, ProvisionOKEvent, PendingState},
		{FailedState, ProvisionPendingEvent, PendingState},
	}
)

// InitState returns the initial FSM state which is the `pending` state.
func InitState() State {
	return PendingState
}

// InitFsm creates a finite state machine by given states
func InitFsm(state State) (*FSM, error) {
	found := false
	for _, v := range validState {
		if v == state {
			found = true
			break
		}
	}
	if !found {
		return nil, fmt.Errorf("invalid state: %s", state)
	}
	return &FSM{currentState: state}, nil
}

// Next turns the function status into properate state by given event.
func (fsm *FSM) Next(event Event) error {
	found := false
	for _, v := range validEvent {
		if v == event {
			found = true
			break
		}
	}
	if !found {
		return fmt.Errorf("unknown event: %s", event)
	}
	for _, v := range transitions {
		if fsm.currentState == v.From && event == v.Event {
			fsm.currentState = v.To
			return nil
		}
	}
	return fmt.Errorf("invalid event: %s, currentState: %s", event, fsm.currentState)
}

// Current gets FSM's current state.
func (fsm *FSM) Current() State {
	return fsm.currentState
}
