/*
 * Copyright (c) 2017, MegaEase
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package v

import (
	"fmt"
	"log"
	"reflect"
	"runtime/debug"
	"strings"

	loadjs "github.com/xeipuuv/gojsonschema"

	"github.com/megaease/easegress/pkg/logger"
	"github.com/megaease/easegress/pkg/util/codectool"
)

type (

	// FormatFunc validates the customized format in json schema.
	// The function could panic if the types are unexpected.
	FormatFunc func(v interface{}) error

	// Validator stands for the types which needs its own Validate function.
	// NOTE: Please always define Validate on non-pointer level Spec.Validate instead of (*Spec).Validate .
	// Based on the mechanism of methods visibility in Golang, if the spec looks like:
	//
	// type Spec struct {
	// 	A 	A
	// 	B 	*B
	//	CC 	[]C
	//	DD 	[]*D
	//	EE 	map[string]E
	//	FF 	map[string]*F
	// }
	//
	// If the methods Validate of all A-F is defined on pointer level:
	// 	A.Validate, CC[i].Validate, EE[i].Validate won't be found.
	// 	B.Validate, DD[i].Validate, FF[i].Validate will be found.
	//
	// But if the methods Validate of all A-F is defined on non-pointer level.
	// All of them will be found.
	//
	// If you really want to define Validate on pointer level,
	// please keep it appear in pointer form within spec. Otherwise, it won't be called.
	Validator interface {
		Validate() error
	}

	// ValidateRecorder records varied errors after validating.
	ValidateRecorder struct {
		// JSONSchemaErrs generated by vendor json schema.
		JSONSchemaErrs []string `json:"jsonschemaErrs,omitempty"`
		// FormatErrs generated by the format function of the single field.
		FormatErrs []string `json:"formatErrs,omitempty"`
		// GeneralErrs generated by Validate() of the Validator itself.
		GeneralErrs []string `json:"generalErrs,omitempty"`

		// SystemErr stands internal error, which often means bugs.
		SystemErr string `json:"systemErr,omitempty"`
	}
)

func (vr *ValidateRecorder) recordJSONSchema(result *loadjs.Result) {
	for _, err := range result.Errors() {
		vr.JSONSchemaErrs = append(vr.JSONSchemaErrs, err.String())
	}
}

func getFieldJSONName(field *reflect.StructField) string {
	fieldName := field.Name

	fieldNames := strings.Split(field.Tag.Get("json"), ",")
	if len(fieldNames) > 0 {
		fieldName = fieldNames[0]
	}

	return fieldName
}

func requiredFromField(field *reflect.StructField) bool {
	tags := strings.Split(field.Tag.Get("jsonschema"), ",")
	switch {
	case len(tags) == 0:
		return false
	case tags[0] == "-":
		return false
	default:
		for _, tag := range tags {
			if tag == "omitempty" {
				return false
			}
		}
		// NOTICE: Required by default.
		return true
	}
}

func (vr *ValidateRecorder) record(val *reflect.Value, field *reflect.StructField) {
	vr.recordFormat(val, field)
	vr.recordGeneral(val, field)
}

func (vr *ValidateRecorder) recordFormat(val *reflect.Value, field *reflect.StructField) {
	if field == nil {
		return
	}

	if !requiredFromField(field) && val.IsZero() {
		return
	}

	tags := strings.Split(field.Tag.Get("jsonschema"), ",")
	for _, tag := range tags {
		nameValue := strings.Split(tag, "=")
		if len(nameValue) != 2 {
			continue
		}

		name, value := nameValue[0], nameValue[1]
		if name != "format" {
			continue
		}

		fn, ok := getFormatFunc(value)
		if !ok {
			logger.Errorf("BUG: format function %s not found", value)
			return
		}

		err := fn(val.Interface())
		if err != nil {
			vr.FormatErrs = append(vr.FormatErrs,
				fmt.Sprintf("%s: %s",
					getFieldJSONName(field),
					err.Error()))
		}
	}
}

func (vr *ValidateRecorder) recordGeneral(val *reflect.Value, field *reflect.StructField) {
	t := val.Type()
	if t.Kind() == reflect.Ptr {
		elemType := t.Elem()

		// NOTE: MethodByName returns the existence of the method
		// only if the method is defined on Spec instead of *Spec.
		// So we need to return here in case of calling Validate twice.
		_, exists := elemType.MethodByName("Validate")
		if exists {
			return
		}
	}

	fieldName := val.Type().String()
	if field != nil {
		fieldName = getFieldJSONName(field)
	}

	v, ok := val.Interface().(Validator)

	if !ok {
		return
	}

	defer func() {
		if r := recover(); r != nil {
			err := fmt.Errorf("BUG: call Validate for %T panic: %v", v, r)
			logger.Errorf("%v: %s", err, debug.Stack())
			vr.recordSystem(err)
		}
	}()

	err := v.Validate()
	if err != nil {
		vr.GeneralErrs = append(vr.GeneralErrs, fmt.Sprintf("%s: %s",
			fieldName,
			err.Error()))
	}
}

func (vr *ValidateRecorder) recordSystem(err error) {
	if err != nil {
		vr.SystemErr = err.Error()
	}
}

func (vr *ValidateRecorder) Error() string {
	return vr.String()
}

func (vr *ValidateRecorder) String() string {
	buff, err := codectool.MarshalJSON(vr)
	if err != nil {
		log.Printf("BUG: marshal %#v to json failed: %v", vr, err)
	}
	return string(buff)
}

// Valid represents if the result is valid.
func (vr *ValidateRecorder) Valid() bool {
	return len(vr.JSONSchemaErrs) == 0 && len(vr.FormatErrs) == 0 &&
		len(vr.GeneralErrs) == 0 && len(vr.SystemErr) == 0
}
